/**
 * angular-permission
 * Route permission and access control as simple as it can get
 * @version v2.3.3 - 2016-04-05
 * @link https://github.com/Narzerus/angular-permission
 * @author Rafael Vidaurre <narzerus@gmail.com> (http://www.rafaelvidaurre.com), Blazej Krysiak <blazej.krysiak@gmail.com>
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */

!function () {
	"use strict";
	var a = angular.module("permission", ["ui.router"]);
	a.config(["$stateProvider", function (a) {
		a.decorator("parent", function (a, b) {
			return a.self.$$state = function () {
				return a
			}, a.self.areSetStatePermissions = function () {
				return angular.isDefined(a.data) && angular.isDefined(a.data.permissions)
			}, b(a)
		})
	}]), a.run(["$rootScope", "TransitionProperties", "TransitionEvents", "StateAuthorization", function (a, b, c, d) {
		a.$on("$stateChangeStart", function (a, e, f, g, h, i) {
			function j() {
				b.toState = e, b.toParams = f, b.fromState = g, b.fromParams = h, b.options = i
			}

			function k(a) {
				angular.extend(e, {$$isAuthorizationFinished: a})
			}

			function l() {
				return e.$$isAuthorizationFinished
			}

			l() || (a.preventDefault(), k(!0), j(), c.areStateEventsDefaultPrevented() || (c.broadcastStateChangePermissionStart(), d.authorize()["finally"](function () {
				k(!1)
			})))
		})
	}])
}(), function () {
	"use strict";
	angular.module("permission").decorator("$q", ["$delegate", function (a) {
		function b(b) {
			var c = a.defer(), d = 0, e = angular.isArray(b) ? [] : {};
			return angular.forEach(b, function (b, f) {
				d++, a.when(b).then(function (a) {
					c.resolve(a)
				})["catch"](function (a) {
					e[f] = a, --d || c.reject(a)
				})
			}), 0 === d && c.reject(e), c.promise
		}

		return a.any = b, a
	}])
}(), function () {
	"use strict";
	angular.module("permission").constant("PermissionStrategies", {
		enableElement: function (a) {
			a.removeAttr("disabled")
		}, disableElement: function (a) {
			a.attr("disabled", "disabled")
		}, showElement: function (a) {
			a.removeClass("ng-hide")
		}, hideElement: function (a) {
			a.addClass("ng-hide")
		}
	})
}(), function () {
	"use strict";
	angular.module("permission").value("TransitionProperties", {
		toState: void 0,
		toParams: void 0,
		fromState: void 0,
		fromParams: void 0,
		options: void 0
	})
}(), function () {
	"use strict";
	angular.module("permission").service("TransitionEvents", ["$rootScope", "TransitionProperties", function (a, b) {
		function c() {
			return i() || h()
		}

		function d() {
			a.$broadcast("$stateChangePermissionStart", b.toState, b.toParams, b.options)
		}

		function e() {
			a.$broadcast("$stateChangePermissionAccepted", b.toState, b.toParams, b.options)
		}

		function f() {
			a.$broadcast("$stateChangeSuccess", b.toState, b.toParams, b.fromState, b.fromParams)
		}

		function g() {
			a.$broadcast("$stateChangePermissionDenied", b.toState, b.toParams, b.options)
		}

		function h() {
			return a.$broadcast("$stateChangeStart", b.toState, b.toParams, b.fromState, b.fromParams, b.options).defaultPrevented
		}

		function i() {
			return a.$broadcast("$stateChangePermissionStart", b.toState, b.toParams, b.options).defaultPrevented
		}

		this.areStateEventsDefaultPrevented = c, this.broadcastStateChangePermissionStart = d, this.broadcastStateChangePermissionAccepted = e, this.broadcastStateChangePermissionDenied = g, this.broadcastStateChangeSuccess = f
	}])
}(), function () {
	"use strict";
	angular.module("permission").factory("PermissionMap", ["$q", "TransitionProperties", function (a, b) {
		function c(a) {
			a = a || {}, this.only = f(a.only), this.except = f(a.except), this.redirectTo = a.redirectTo
		}

		function d(b, c) {
			return a.when(b.call(null, c)).then(function (a) {
				if (angular.isString(a))return {state: a};
				if (angular.isObject(a))return a;
				throw new TypeError('When used "redirectTo" as function, returned value must be string or object')
			})
		}

		function e(b, c) {
			if (!angular.isDefined(b["default"]))throw new ReferenceError('When used "redirectTo" as object, property "default" must be defined');
			var e = b[c];
			return angular.isDefined(e) || (e = b["default"]), angular.isFunction(e) ? d(e, c) : angular.isObject(e) ? a.resolve(e) : angular.isString(e) ? a.resolve({state: e}) : void 0
		}

		function f(a) {
			return angular.isString(a) ? [a] : angular.isArray(a) ? a : angular.isFunction(a) ? a.call(null, b) : []
		}

		return c.prototype.extendPermissionMap = function (a) {
			a.only.length && (this.only = this.only.concat([a.only])), a.except.length && (this.except = this.except.concat([a.except])), this.redirectTo = a.redirectTo
		}, c.prototype.resolveRedirectState = function (b) {
			return angular.isFunction(this.redirectTo) ? d(this.redirectTo, b) : angular.isObject(this.redirectTo) ? e(this.redirectTo, b) : angular.isString(this.redirectTo) ? a.resolve({state: this.redirectTo}) : a.reject(null)
		}, c.prototype.isStatePermissionMap = function () {
			return !(!angular.isArray(this.only[0]) && !angular.isArray(this.except[0]))
		}, c
	}])
}(), function () {
	"use strict";
	angular.module("permission").factory("Permission", ["$q", "TransitionProperties", function (a, b) {
		function c(a, b) {
			e(a, b), this.permissionName = a, this.validationFunction = b
		}

		function d(b, c) {
			var d = a.defer();
			return b ? d.resolve(c) : d.reject(c), d.promise
		}

		function e(a, b) {
			if (!angular.isString(a))throw new TypeError('Parameter "permissionName" name must be String');
			if (!angular.isFunction(b))throw new TypeError('Parameter "validationFunction" must be Function')
		}

		return c.prototype.validatePermission = function () {
			var a = this.validationFunction.call(null, this.permissionName, b);
			return angular.isFunction(a.then) || (a = d(a, this.permissionName)), a
		}, c
	}])
}(), function () {
	"use strict";
	angular.module("permission").factory("Role", ["$q", "PermissionStore", "TransitionProperties", function (a, b, c) {
		function d(a, c, d) {
			return f(a, c, d), this.roleName = a, this.permissionNames = c || [], this.validationFunction = d, d && b.defineManyPermissions(c, d), this
		}

		function e(b, c) {
			var d = a.defer();
			return b ? d.resolve(c) : d.reject(c), d.promise
		}

		function f(a, b, c) {
			if (!angular.isString(a))throw new TypeError('Parameter "roleName" name must be String');
			if (!angular.isArray(b))throw new TypeError('Parameter "permissionNames" must be Array');
			if (!b.length && !angular.isFunction(c))throw new TypeError('Parameter "validationFunction" must be provided for empty "permissionNames" array')
		}

		return d.prototype.validateRole = function () {
			if (this.permissionNames.length) {
				var d = this.permissionNames.map(function (d) {
					if (b.hasPermissionDefinition(d)) {
						var f = b.getPermissionDefinition(d), g = f.validationFunction.call(null, f.permissionName, c);
						return angular.isFunction(g.then) || (g = e(g)), g
					}
					return a.reject()
				});
				return a.all(d)
			}
			var f = this.validationFunction.call(null, this.roleName, c);
			return angular.isFunction(f.then) || (f = e(f, this.roleName)), a.resolve(f)
		}, d
	}])
}(), function () {
	"use strict";
	angular.module("permission").service("PermissionStore", ["Permission", function (a) {
		function b(b, c) {
			i[b] = new a(b, c)
		}

		function c(a, c) {
			if (!angular.isArray(a))throw new TypeError('Parameter "permissionNames" name must be Array');
			angular.forEach(a, function (a) {
				b(a, c)
			})
		}

		function d(a) {
			delete i[a]
		}

		function e(a) {
			return angular.isDefined(i[a])
		}

		function f(a) {
			return i[a]
		}

		function g() {
			return i
		}

		function h() {
			i = {}
		}

		var i = {};
		this.definePermission = b, this.defineManyPermissions = c, this.removePermissionDefinition = d, this.hasPermissionDefinition = e, this.getPermissionDefinition = f, this.getStore = g, this.clearStore = h
	}])
}(), function () {
	"use strict";
	angular.module("permission").service("RoleStore", ["Role", function (a) {
		function b(b, c, d) {
			h[b] = new a(b, c, d)
		}

		function c(a) {
			delete h[a]
		}

		function d(a) {
			return angular.isDefined(h[a])
		}

		function e(a) {
			return h[a]
		}

		function f() {
			return h
		}

		function g() {
			h = {}
		}

		var h = {};
		this.defineRole = b, this.getRoleDefinition = e, this.hasRoleDefinition = d, this.removeRoleDefinition = c, this.getStore = f, this.clearStore = g
	}])
}(), function () {
	"use strict";
	angular.module("permission").directive("permission", ["$log", "Authorization", "PermissionMap", "PermissionStrategies", function (a, b, c, d) {
		return {
			restrict: "A",
			scope: !1,
			bindToController: {
				only: "=?permissionOnly",
				except: "=?permissionExcept",
				onAuthorized: "&?permissionOnAuthorized",
				onUnauthorized: "&?permissionOnUnauthorized",
				deprecatedOnly: "=only",
				deprecatedExcept: "=except"
			},
			controllerAs: "permission",
			controller: ["$scope", "$element", function (e, f) {
				function g() {
					angular.isFunction(i.onAuthorized) ? i.onAuthorized()(f) : d.showElement(f)
				}

				function h() {
					angular.isFunction(i.onUnauthorized) ? i.onUnauthorized()(f) : d.hideElement(f)
				}

				var i = this;
				(angular.isDefined(i.deprecatedOnly) || angular.isDefined(i.deprecatedExcept)) && a.warn('Attributes "only" and "except" are deprecated since 2.2.0+ and their support will be removed from 2.4.0. Use scoped "permission-only" and "permission-except" instead.'), e.$watchGroup(["permission.only", "permission.except", "permission.deprecatedOnly", "permission.deprecatedExcept"], function () {
					try {
						var d = new c({only: i.only || i.deprecatedOnly, except: i.except || i.deprecatedExcept});
						b.authorize(d).then(function () {
							g()
						})["catch"](function () {
							h()
						})
					} catch (e) {
						h(), a.error(e.message)
					}
				})
			}]
		}
	}])
}(), function () {
	"use strict";
	angular.module("permission").service("Authorization", ["$q", "PermissionStore", "RoleStore", function (a, b, c) {
		function d(a) {
			return a.isStatePermissionMap() ? e(a) : h(a)
		}

		function e(b) {
			var c = a.defer();
			return f(b, c), c.promise
		}

		function f(b, c) {
			var d = k(b.except);
			a.all(d).then(function (a) {
				c.reject(a)
			})["catch"](function () {
				g(b, c)
			})
		}

		function g(b, c) {
			if (!b.only.length)return void c.resolve();
			var d = k(b.only);
			a.all(d).then(function (a) {
				c.resolve(a)
			})["catch"](function (a) {
				c.reject(a)
			})
		}

		function h(b) {
			var c = a.defer();
			return i(b, c), c.promise
		}

		function i(b, c) {
			var d = l(b.except);
			a.any(d).then(function (a) {
				c.reject(a)
			})["catch"](function () {
				j(b, c)
			})
		}

		function j(b, c) {
			if (!b.only.length)return void c.resolve();
			var d = l(b.only);
			a.any(d).then(function (a) {
				c.resolve(a)
			})["catch"](function (a) {
				c.reject(a)
			})
		}

		function k(b) {
			return b.length ? b.map(function (b) {
				var c = l(b);
				return a.any(c)
			}) : [a.reject()]
		}

		function l(d) {
			return d.map(function (d) {
				if (c.hasRoleDefinition(d)) {
					var e = c.getRoleDefinition(d);
					return e.validateRole()
				}
				if (b.hasPermissionDefinition(d)) {
					var f = b.getPermissionDefinition(d);
					return f.validatePermission()
				}
				return a.reject(d)
			})
		}

		this.authorize = d
	}])
}(), function () {
	"use strict";
	angular.module("permission").service("StateAuthorization", ["$location", "$state", "PermissionMap", "Authorization", "TransitionEvents", "TransitionProperties", function (a, b, c, d, e, f) {
		function g() {
			var a = h();
			return d.authorize(a).then(function () {
				i()
			})["catch"](function (b) {
				j(a, b)
			})
		}

		function h() {
			var a = new c, d = b.get(f.toState.name).$$state().path.slice().reverse();
			return d.forEach(function (b) {
				b.areSetStatePermissions() && a.extendPermissionMap(new c(b.data.permissions))
			}), a
		}

		function i() {
			e.broadcastStateChangePermissionAccepted(), a.replace(), f.options = angular.extend({}, f.options, {notify: !1}), b.go(f.toState.name, f.toParams, f.options).then(function () {
				e.broadcastStateChangeSuccess()
			})
		}

		function j(a, c) {
			e.broadcastStateChangePermissionDenied(), a.resolveRedirectState(c).then(function (a) {
				b.go(a.state, a.params, a.options)
			})
		}

		this.authorize = g
	}])
}();
//# sourceMappingURL=angular-permission.min.js.map